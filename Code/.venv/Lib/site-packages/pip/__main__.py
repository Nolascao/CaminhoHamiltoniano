def is_valid(vertex, graph, path, position):
 """
 Verifica se é válido adicionar o vértice ao caminho atual.
 """
 # Verifica se há uma aresta entre o último vértice no caminho e o vértice atual
 if graph[path[position - 1]][vertex] == 0:
     return False

 # Verifica se o vértice já foi visitado
 if vertex in path:
     return False

 return True

def hamiltonian_path_util(graph, path, position):
 """
 Função recursiva para encontrar o Caminho Hamiltoniano usando backtracking.
 """
 # Caso base: se todos os vértices estão no caminho
 if position == len(graph):
     return True

 # Tenta adicionar cada vértice ao caminho
 for vertex in range(len(graph)):
     if is_valid(vertex, graph, path, position):
         path[position] = vertex

         # Recursivamente tenta construir o caminho
         if hamiltonian_path_util(graph, path, position + 1):
             return True

         # Se não funcionar, remove o vértice do caminho (backtracking)
         path[position] = -1

 return False

def find_hamiltonian_path(graph):
 """
 Encontra um Caminho Hamiltoniano no grafo dado.
 """
 n = len(graph)
 path = [-1] * n  # Inicializa o caminho com -1
 path[0] = 0      # Começa pelo primeiro vértice

 if not hamiltonian_path_util(graph, path, 1):
     print("Não existe um Caminho Hamiltoniano no grafo.")
     return None

 print("Caminho Hamiltoniano encontrado:")
 print(path)
 return path


def main():
    """
    Função principal que permite ao usuário inserir a entrada.
    """
    print("Exemplo de entrada (matriz de adjacência):")
    print("""
 Para um grafo com 4 vértices:
 [[0, 1, 1, 0],[1, 0, 1, 1],[1, 1, 0, 1],[0, 1, 1, 0]] 
 Sendo que cada Lista é uma linda da matriz de adjacência.
 Isso representa as conexões entre os vértices:
 - Vértice 0 conectado aos vértices 1 e 2.
 - Vértice 1 conectado aos vértices 0, 2 e 3.
 - Vértice 2 conectado aos vértices 0, 1 e 3.
 - Vértice 3 conectado aos vértices 1 e 2.
 """)

    print("\nInsira sua matriz de adjacência (como uma lista de listas):")
    try:
        user_input = input("Digite a matriz de adjacência: ")
        graph = eval(user_input)  # Converte a entrada do usuário para uma lista de listas
        if not isinstance(graph, list) or not all(isinstance(row, list) for row in graph):
            raise ValueError("A entrada deve ser uma lista de listas.")

        # Verifica se a matriz é quadrada
        n = len(graph)
        if not all(len(row) == n for row in graph):
            raise ValueError("A matriz de adjacência deve ser quadrada.")

        # Executa o algoritmo
        find_hamiltonian_path(graph)
    except Exception as e:
        print(f"Erro na entrada: {e}")
        print("Certifique-se de inserir uma matriz de adjacência válida no formato correto.")


if __name__ == "__main__":
    main()